/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_CHLOLEGALIZETOSTABLEHLOPASS
#define GEN_PASS_DECL_SHAPELEGALIZETOSTABLEHLOPASS
#define GEN_PASS_DECL_STABLEHLOAGGRESSIVEFOLDERPASS
#define GEN_PASS_DECL_STABLEHLOAGGRESSIVESIMPLIFICATIONPASS
#define GEN_PASS_DECL_STABLEHLOCANONICALIZEDYNAMISMPASS
#define GEN_PASS_DECL_STABLEHLOCONVERTTOSIGNLESSPASS
#define GEN_PASS_DECL_STABLEHLOINSTRUMENTWITHPROBEPASS
#define GEN_PASS_DECL_STABLEHLOLEGALIZECOMPOSITETOCALLPASS
#define GEN_PASS_DECL_STABLEHLOLEGALIZEDEPRECATEDOPSPASS
#define GEN_PASS_DECL_STABLEHLOLEGALIZETOVHLOPASS
#define GEN_PASS_DECL_STABLEHLOREFINEARGUMENTSPASS
#define GEN_PASS_DECL_STABLEHLOREFINESHAPESPASS
#define GEN_PASS_DECL_VHLOLEGALIZETOSTABLEHLOPASS
#define GEN_PASS_DECL_VHLOTOVERSIONPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// ChloLegalizeToStablehloPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CHLOLEGALIZETOSTABLEHLOPASS
std::unique_ptr<::mlir::Pass> createChloLegalizeToStablehloPass();
#undef GEN_PASS_DECL_CHLOLEGALIZETOSTABLEHLOPASS
#endif // GEN_PASS_DECL_CHLOLEGALIZETOSTABLEHLOPASS
#ifdef GEN_PASS_DEF_CHLOLEGALIZETOSTABLEHLOPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createChloLegalizeToStablehloPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ChloLegalizeToStablehloPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = ChloLegalizeToStablehloPassBase;

  ChloLegalizeToStablehloPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ChloLegalizeToStablehloPassBase(const ChloLegalizeToStablehloPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  ChloLegalizeToStablehloPassBase& operator=(const ChloLegalizeToStablehloPassBase &) = delete;
  ChloLegalizeToStablehloPassBase(ChloLegalizeToStablehloPassBase &&) = delete;
  ChloLegalizeToStablehloPassBase& operator=(ChloLegalizeToStablehloPassBase &&) = delete;
  ~ChloLegalizeToStablehloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("chlo-legalize-to-stablehlo");
  }
  ::llvm::StringRef getArgument() const override { return "chlo-legalize-to-stablehlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes from CHLO ops flow to StableHLO and Shape ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ChloLegalizeToStablehloPass");
  }
  ::llvm::StringRef getName() const override { return "ChloLegalizeToStablehloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::shape::ShapeDialect>();
    registry.insert<mlir::stablehlo::StablehloDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ChloLegalizeToStablehloPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createChloLegalizeToStablehloPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createChloLegalizeToStablehloPass() {
  return impl::createChloLegalizeToStablehloPass();
}
#undef GEN_PASS_DEF_CHLOLEGALIZETOSTABLEHLOPASS
#endif // GEN_PASS_DEF_CHLOLEGALIZETOSTABLEHLOPASS

//===----------------------------------------------------------------------===//
// ShapeLegalizeToStablehloPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SHAPELEGALIZETOSTABLEHLOPASS
std::unique_ptr<::mlir::Pass> createShapeLegalizeToStablehloPass();
#undef GEN_PASS_DECL_SHAPELEGALIZETOSTABLEHLOPASS
#endif // GEN_PASS_DECL_SHAPELEGALIZETOSTABLEHLOPASS
#ifdef GEN_PASS_DEF_SHAPELEGALIZETOSTABLEHLOPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createShapeLegalizeToStablehloPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ShapeLegalizeToStablehloPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = ShapeLegalizeToStablehloPassBase;

  ShapeLegalizeToStablehloPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeLegalizeToStablehloPassBase(const ShapeLegalizeToStablehloPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  ShapeLegalizeToStablehloPassBase& operator=(const ShapeLegalizeToStablehloPassBase &) = delete;
  ShapeLegalizeToStablehloPassBase(ShapeLegalizeToStablehloPassBase &&) = delete;
  ShapeLegalizeToStablehloPassBase& operator=(ShapeLegalizeToStablehloPassBase &&) = delete;
  ~ShapeLegalizeToStablehloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-legalize-to-stablehlo");
  }
  ::llvm::StringRef getArgument() const override { return "shape-legalize-to-stablehlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize shape-related ops to StableHLO."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeLegalizeToStablehloPass");
  }
  ::llvm::StringRef getName() const override { return "ShapeLegalizeToStablehloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeLegalizeToStablehloPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createShapeLegalizeToStablehloPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createShapeLegalizeToStablehloPass() {
  return impl::createShapeLegalizeToStablehloPass();
}
#undef GEN_PASS_DEF_SHAPELEGALIZETOSTABLEHLOPASS
#endif // GEN_PASS_DEF_SHAPELEGALIZETOSTABLEHLOPASS

//===----------------------------------------------------------------------===//
// StablehloAggressiveFolderPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOAGGRESSIVEFOLDERPASS
std::unique_ptr<::mlir::Pass> createStablehloAggressiveFolderPass();
#undef GEN_PASS_DECL_STABLEHLOAGGRESSIVEFOLDERPASS
#endif // GEN_PASS_DECL_STABLEHLOAGGRESSIVEFOLDERPASS
#ifdef GEN_PASS_DEF_STABLEHLOAGGRESSIVEFOLDERPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloAggressiveFolderPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloAggressiveFolderPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloAggressiveFolderPassBase;

  StablehloAggressiveFolderPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloAggressiveFolderPassBase(const StablehloAggressiveFolderPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloAggressiveFolderPassBase& operator=(const StablehloAggressiveFolderPassBase &) = delete;
  StablehloAggressiveFolderPassBase(StablehloAggressiveFolderPassBase &&) = delete;
  StablehloAggressiveFolderPassBase& operator=(StablehloAggressiveFolderPassBase &&) = delete;
  ~StablehloAggressiveFolderPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-aggressive-folder");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-aggressive-folder"; }

  ::llvm::StringRef getDescription() const override { return "Folds StableHLO operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloAggressiveFolderPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloAggressiveFolderPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloAggressiveFolderPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloAggressiveFolderPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloAggressiveFolderPass() {
  return impl::createStablehloAggressiveFolderPass();
}
#undef GEN_PASS_DEF_STABLEHLOAGGRESSIVEFOLDERPASS
#endif // GEN_PASS_DEF_STABLEHLOAGGRESSIVEFOLDERPASS

//===----------------------------------------------------------------------===//
// StablehloAggressiveSimplificationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOAGGRESSIVESIMPLIFICATIONPASS
std::unique_ptr<::mlir::Pass> createStablehloAggressiveSimplificationPass();
#undef GEN_PASS_DECL_STABLEHLOAGGRESSIVESIMPLIFICATIONPASS
#endif // GEN_PASS_DECL_STABLEHLOAGGRESSIVESIMPLIFICATIONPASS
#ifdef GEN_PASS_DEF_STABLEHLOAGGRESSIVESIMPLIFICATIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloAggressiveSimplificationPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloAggressiveSimplificationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloAggressiveSimplificationPassBase;

  StablehloAggressiveSimplificationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloAggressiveSimplificationPassBase(const StablehloAggressiveSimplificationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloAggressiveSimplificationPassBase& operator=(const StablehloAggressiveSimplificationPassBase &) = delete;
  StablehloAggressiveSimplificationPassBase(StablehloAggressiveSimplificationPassBase &&) = delete;
  StablehloAggressiveSimplificationPassBase& operator=(StablehloAggressiveSimplificationPassBase &&) = delete;
  ~StablehloAggressiveSimplificationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-aggressive-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-aggressive-simplification"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalizes StableHLO operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloAggressiveSimplificationPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloAggressiveSimplificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloAggressiveSimplificationPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloAggressiveSimplificationPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloAggressiveSimplificationPass() {
  return impl::createStablehloAggressiveSimplificationPass();
}
#undef GEN_PASS_DEF_STABLEHLOAGGRESSIVESIMPLIFICATIONPASS
#endif // GEN_PASS_DEF_STABLEHLOAGGRESSIVESIMPLIFICATIONPASS

//===----------------------------------------------------------------------===//
// StablehloCanonicalizeDynamismPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOCANONICALIZEDYNAMISMPASS
std::unique_ptr<::mlir::Pass> createStablehloCanonicalizeDynamismPass();
#undef GEN_PASS_DECL_STABLEHLOCANONICALIZEDYNAMISMPASS
#endif // GEN_PASS_DECL_STABLEHLOCANONICALIZEDYNAMISMPASS
#ifdef GEN_PASS_DEF_STABLEHLOCANONICALIZEDYNAMISMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloCanonicalizeDynamismPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloCanonicalizeDynamismPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloCanonicalizeDynamismPassBase;

  StablehloCanonicalizeDynamismPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloCanonicalizeDynamismPassBase(const StablehloCanonicalizeDynamismPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloCanonicalizeDynamismPassBase& operator=(const StablehloCanonicalizeDynamismPassBase &) = delete;
  StablehloCanonicalizeDynamismPassBase(StablehloCanonicalizeDynamismPassBase &&) = delete;
  StablehloCanonicalizeDynamismPassBase& operator=(StablehloCanonicalizeDynamismPassBase &&) = delete;
  ~StablehloCanonicalizeDynamismPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-canonicalize-dynamism");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-canonicalize-dynamism"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalizes dynamic StableHLO ops into static ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloCanonicalizeDynamismPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloCanonicalizeDynamismPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloCanonicalizeDynamismPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloCanonicalizeDynamismPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloCanonicalizeDynamismPass() {
  return impl::createStablehloCanonicalizeDynamismPass();
}
#undef GEN_PASS_DEF_STABLEHLOCANONICALIZEDYNAMISMPASS
#endif // GEN_PASS_DEF_STABLEHLOCANONICALIZEDYNAMISMPASS

//===----------------------------------------------------------------------===//
// StablehloConvertToSignlessPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOCONVERTTOSIGNLESSPASS
std::unique_ptr<::mlir::Pass> createStablehloConvertToSignlessPass();
#undef GEN_PASS_DECL_STABLEHLOCONVERTTOSIGNLESSPASS
#endif // GEN_PASS_DECL_STABLEHLOCONVERTTOSIGNLESSPASS
#ifdef GEN_PASS_DEF_STABLEHLOCONVERTTOSIGNLESSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloConvertToSignlessPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloConvertToSignlessPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StablehloConvertToSignlessPassBase;

  StablehloConvertToSignlessPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloConvertToSignlessPassBase(const StablehloConvertToSignlessPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StablehloConvertToSignlessPassBase& operator=(const StablehloConvertToSignlessPassBase &) = delete;
  StablehloConvertToSignlessPassBase(StablehloConvertToSignlessPassBase &&) = delete;
  StablehloConvertToSignlessPassBase& operator=(StablehloConvertToSignlessPassBase &&) = delete;
  ~StablehloConvertToSignlessPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-convert-to-signless");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-convert-to-signless"; }

  ::llvm::StringRef getDescription() const override { return "Pass to transform the IR to be on signless integers."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloConvertToSignlessPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloConvertToSignlessPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloConvertToSignlessPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloConvertToSignlessPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloConvertToSignlessPass() {
  return impl::createStablehloConvertToSignlessPass();
}
#undef GEN_PASS_DEF_STABLEHLOCONVERTTOSIGNLESSPASS
#endif // GEN_PASS_DEF_STABLEHLOCONVERTTOSIGNLESSPASS

//===----------------------------------------------------------------------===//
// StablehloInstrumentWithProbePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOINSTRUMENTWITHPROBEPASS
struct StablehloInstrumentWithProbePassOptions {
  bool useDebugInfoOption = false;
};
std::unique_ptr<::mlir::Pass> createStablehloInstrumentWithProbePass();
std::unique_ptr<::mlir::Pass> createStablehloInstrumentWithProbePass(const StablehloInstrumentWithProbePassOptions &options);
#undef GEN_PASS_DECL_STABLEHLOINSTRUMENTWITHPROBEPASS
#endif // GEN_PASS_DECL_STABLEHLOINSTRUMENTWITHPROBEPASS
#ifdef GEN_PASS_DEF_STABLEHLOINSTRUMENTWITHPROBEPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloInstrumentWithProbePass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloInstrumentWithProbePass(const StablehloInstrumentWithProbePassOptions &options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloInstrumentWithProbePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StablehloInstrumentWithProbePassBase;

  StablehloInstrumentWithProbePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloInstrumentWithProbePassBase(const StablehloInstrumentWithProbePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StablehloInstrumentWithProbePassBase& operator=(const StablehloInstrumentWithProbePassBase &) = delete;
  StablehloInstrumentWithProbePassBase(StablehloInstrumentWithProbePassBase &&) = delete;
  StablehloInstrumentWithProbePassBase& operator=(StablehloInstrumentWithProbePassBase &&) = delete;
  ~StablehloInstrumentWithProbePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-instrument-with-probe");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-instrument-with-probe"; }

  ::llvm::StringRef getDescription() const override { return "Inserts probe instrumentation instructions in a StableHLO program."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloInstrumentWithProbePass");
  }
  ::llvm::StringRef getName() const override { return "StablehloInstrumentWithProbePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::stablehlo::interpreter::InterpreterDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloInstrumentWithProbePassBase<DerivedT>)

  StablehloInstrumentWithProbePassBase(const StablehloInstrumentWithProbePassOptions &options) : StablehloInstrumentWithProbePassBase() {
    useDebugInfoOption = options.useDebugInfoOption;
  }
protected:
  ::mlir::Pass::Option<bool> useDebugInfoOption{*this, "useDebugInfo", ::llvm::cl::desc("Whether or not to use location debug data as `probe_id` values."), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloInstrumentWithProbePass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createStablehloInstrumentWithProbePass(const StablehloInstrumentWithProbePassOptions &options) {
    return std::make_unique<DerivedT>(options);
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloInstrumentWithProbePass() {
  return impl::createStablehloInstrumentWithProbePass();
}

std::unique_ptr<::mlir::Pass> createStablehloInstrumentWithProbePass(const StablehloInstrumentWithProbePassOptions &options) {
  return impl::createStablehloInstrumentWithProbePass(options);
}
#undef GEN_PASS_DEF_STABLEHLOINSTRUMENTWITHPROBEPASS
#endif // GEN_PASS_DEF_STABLEHLOINSTRUMENTWITHPROBEPASS

//===----------------------------------------------------------------------===//
// StablehloLegalizeCompositeToCallPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOLEGALIZECOMPOSITETOCALLPASS
struct StablehloLegalizeCompositeToCallPassOptions {
  ::llvm::ArrayRef<std::string> exceptListOption;
};
std::unique_ptr<::mlir::Pass> createStablehloLegalizeCompositeToCallPass();
std::unique_ptr<::mlir::Pass> createStablehloLegalizeCompositeToCallPass(const StablehloLegalizeCompositeToCallPassOptions &options);
#undef GEN_PASS_DECL_STABLEHLOLEGALIZECOMPOSITETOCALLPASS
#endif // GEN_PASS_DECL_STABLEHLOLEGALIZECOMPOSITETOCALLPASS
#ifdef GEN_PASS_DEF_STABLEHLOLEGALIZECOMPOSITETOCALLPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloLegalizeCompositeToCallPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloLegalizeCompositeToCallPass(const StablehloLegalizeCompositeToCallPassOptions &options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloLegalizeCompositeToCallPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloLegalizeCompositeToCallPassBase;

  StablehloLegalizeCompositeToCallPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloLegalizeCompositeToCallPassBase(const StablehloLegalizeCompositeToCallPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloLegalizeCompositeToCallPassBase& operator=(const StablehloLegalizeCompositeToCallPassBase &) = delete;
  StablehloLegalizeCompositeToCallPassBase(StablehloLegalizeCompositeToCallPassBase &&) = delete;
  StablehloLegalizeCompositeToCallPassBase& operator=(StablehloLegalizeCompositeToCallPassBase &&) = delete;
  ~StablehloLegalizeCompositeToCallPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-legalize-composite-to-call");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-legalize-composite-to-call"; }

  ::llvm::StringRef getDescription() const override { return "Replaces composite ops with a call to their decomposition"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloLegalizeCompositeToCallPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloLegalizeCompositeToCallPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloLegalizeCompositeToCallPassBase<DerivedT>)

  StablehloLegalizeCompositeToCallPassBase(const StablehloLegalizeCompositeToCallPassOptions &options) : StablehloLegalizeCompositeToCallPassBase() {
    exceptListOption = options.exceptListOption;
  }
protected:
  ::mlir::Pass::ListOption<std::string> exceptListOption{*this, "except", ::llvm::cl::desc("Names of composites that should not be replaced with calls.")};
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloLegalizeCompositeToCallPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createStablehloLegalizeCompositeToCallPass(const StablehloLegalizeCompositeToCallPassOptions &options) {
    return std::make_unique<DerivedT>(options);
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloLegalizeCompositeToCallPass() {
  return impl::createStablehloLegalizeCompositeToCallPass();
}

std::unique_ptr<::mlir::Pass> createStablehloLegalizeCompositeToCallPass(const StablehloLegalizeCompositeToCallPassOptions &options) {
  return impl::createStablehloLegalizeCompositeToCallPass(options);
}
#undef GEN_PASS_DEF_STABLEHLOLEGALIZECOMPOSITETOCALLPASS
#endif // GEN_PASS_DEF_STABLEHLOLEGALIZECOMPOSITETOCALLPASS

//===----------------------------------------------------------------------===//
// StablehloLegalizeDeprecatedOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOLEGALIZEDEPRECATEDOPSPASS
struct StablehloLegalizeDeprecatedOpsPassOptions {
  bool failOnUnusedOps = true;
};
std::unique_ptr<::mlir::Pass> createStablehloLegalizeDeprecatedOpsPass();
std::unique_ptr<::mlir::Pass> createStablehloLegalizeDeprecatedOpsPass(const StablehloLegalizeDeprecatedOpsPassOptions &options);
#undef GEN_PASS_DECL_STABLEHLOLEGALIZEDEPRECATEDOPSPASS
#endif // GEN_PASS_DECL_STABLEHLOLEGALIZEDEPRECATEDOPSPASS
#ifdef GEN_PASS_DEF_STABLEHLOLEGALIZEDEPRECATEDOPSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloLegalizeDeprecatedOpsPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloLegalizeDeprecatedOpsPass(const StablehloLegalizeDeprecatedOpsPassOptions &options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloLegalizeDeprecatedOpsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloLegalizeDeprecatedOpsPassBase;

  StablehloLegalizeDeprecatedOpsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloLegalizeDeprecatedOpsPassBase(const StablehloLegalizeDeprecatedOpsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloLegalizeDeprecatedOpsPassBase& operator=(const StablehloLegalizeDeprecatedOpsPassBase &) = delete;
  StablehloLegalizeDeprecatedOpsPassBase(StablehloLegalizeDeprecatedOpsPassBase &&) = delete;
  StablehloLegalizeDeprecatedOpsPassBase& operator=(StablehloLegalizeDeprecatedOpsPassBase &&) = delete;
  ~StablehloLegalizeDeprecatedOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-legalize-deprecated-ops");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-legalize-deprecated-ops"; }

  ::llvm::StringRef getDescription() const override { return "Legalize deprecated ops to well-supported ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloLegalizeDeprecatedOpsPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloLegalizeDeprecatedOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloLegalizeDeprecatedOpsPassBase<DerivedT>)

  StablehloLegalizeDeprecatedOpsPassBase(const StablehloLegalizeDeprecatedOpsPassOptions &options) : StablehloLegalizeDeprecatedOpsPassBase() {
    failOnUnusedOps = options.failOnUnusedOps;
  }
protected:
  ::mlir::Pass::Option<bool> failOnUnusedOps{*this, "fail-on-unused", ::llvm::cl::desc("Fail on (mostly) unused ops that are deprecated without any fallback."), ::llvm::cl::init(true)};
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloLegalizeDeprecatedOpsPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createStablehloLegalizeDeprecatedOpsPass(const StablehloLegalizeDeprecatedOpsPassOptions &options) {
    return std::make_unique<DerivedT>(options);
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloLegalizeDeprecatedOpsPass() {
  return impl::createStablehloLegalizeDeprecatedOpsPass();
}

std::unique_ptr<::mlir::Pass> createStablehloLegalizeDeprecatedOpsPass(const StablehloLegalizeDeprecatedOpsPassOptions &options) {
  return impl::createStablehloLegalizeDeprecatedOpsPass(options);
}
#undef GEN_PASS_DEF_STABLEHLOLEGALIZEDEPRECATEDOPSPASS
#endif // GEN_PASS_DEF_STABLEHLOLEGALIZEDEPRECATEDOPSPASS

//===----------------------------------------------------------------------===//
// StablehloLegalizeToVhloPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOLEGALIZETOVHLOPASS
std::unique_ptr<::mlir::Pass> createStablehloLegalizeToVhloPass();
#undef GEN_PASS_DECL_STABLEHLOLEGALIZETOVHLOPASS
#endif // GEN_PASS_DECL_STABLEHLOLEGALIZETOVHLOPASS
#ifdef GEN_PASS_DEF_STABLEHLOLEGALIZETOVHLOPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloLegalizeToVhloPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloLegalizeToVhloPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StablehloLegalizeToVhloPassBase;

  StablehloLegalizeToVhloPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloLegalizeToVhloPassBase(const StablehloLegalizeToVhloPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StablehloLegalizeToVhloPassBase& operator=(const StablehloLegalizeToVhloPassBase &) = delete;
  StablehloLegalizeToVhloPassBase(StablehloLegalizeToVhloPassBase &&) = delete;
  StablehloLegalizeToVhloPassBase& operator=(StablehloLegalizeToVhloPassBase &&) = delete;
  ~StablehloLegalizeToVhloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-legalize-to-vhlo");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-legalize-to-vhlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize StableHLO to VHLO."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloLegalizeToVhloPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloLegalizeToVhloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vhlo::VhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloLegalizeToVhloPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloLegalizeToVhloPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloLegalizeToVhloPass() {
  return impl::createStablehloLegalizeToVhloPass();
}
#undef GEN_PASS_DEF_STABLEHLOLEGALIZETOVHLOPASS
#endif // GEN_PASS_DEF_STABLEHLOLEGALIZETOVHLOPASS

//===----------------------------------------------------------------------===//
// StablehloRefineArgumentsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOREFINEARGUMENTSPASS
struct StablehloRefineArgumentsPassOptions {
  ::llvm::ArrayRef<std::string> refinedTypesOption;
};
std::unique_ptr<::mlir::Pass> createStablehloRefineArgumentsPass();
std::unique_ptr<::mlir::Pass> createStablehloRefineArgumentsPass(const StablehloRefineArgumentsPassOptions &options);
#undef GEN_PASS_DECL_STABLEHLOREFINEARGUMENTSPASS
#endif // GEN_PASS_DECL_STABLEHLOREFINEARGUMENTSPASS
#ifdef GEN_PASS_DEF_STABLEHLOREFINEARGUMENTSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloRefineArgumentsPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloRefineArgumentsPass(const StablehloRefineArgumentsPassOptions &options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloRefineArgumentsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StablehloRefineArgumentsPassBase;

  StablehloRefineArgumentsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloRefineArgumentsPassBase(const StablehloRefineArgumentsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StablehloRefineArgumentsPassBase& operator=(const StablehloRefineArgumentsPassBase &) = delete;
  StablehloRefineArgumentsPassBase(StablehloRefineArgumentsPassBase &&) = delete;
  StablehloRefineArgumentsPassBase& operator=(StablehloRefineArgumentsPassBase &&) = delete;
  ~StablehloRefineArgumentsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-refine-arguments");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-refine-arguments"; }

  ::llvm::StringRef getDescription() const override { return "Refines the argument shapes of the main function."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloRefineArgumentsPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloRefineArgumentsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloRefineArgumentsPassBase<DerivedT>)

  StablehloRefineArgumentsPassBase(const StablehloRefineArgumentsPassOptions &options) : StablehloRefineArgumentsPassBase() {
    refinedTypesOption = options.refinedTypesOption;
  }
protected:
  ::mlir::Pass::ListOption<std::string> refinedTypesOption{*this, "types", ::llvm::cl::desc("The new types to be used for the main function's arguments, specified as an MLIR TypeRange 'tensor<1x2xf32>, ...'")};
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloRefineArgumentsPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createStablehloRefineArgumentsPass(const StablehloRefineArgumentsPassOptions &options) {
    return std::make_unique<DerivedT>(options);
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloRefineArgumentsPass() {
  return impl::createStablehloRefineArgumentsPass();
}

std::unique_ptr<::mlir::Pass> createStablehloRefineArgumentsPass(const StablehloRefineArgumentsPassOptions &options) {
  return impl::createStablehloRefineArgumentsPass(options);
}
#undef GEN_PASS_DEF_STABLEHLOREFINEARGUMENTSPASS
#endif // GEN_PASS_DEF_STABLEHLOREFINEARGUMENTSPASS

//===----------------------------------------------------------------------===//
// StablehloRefineShapesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOREFINESHAPESPASS
std::unique_ptr<::mlir::Pass> createStablehloRefineShapesPass();
#undef GEN_PASS_DECL_STABLEHLOREFINESHAPESPASS
#endif // GEN_PASS_DECL_STABLEHLOREFINESHAPESPASS
#ifdef GEN_PASS_DEF_STABLEHLOREFINESHAPESPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloRefineShapesPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloRefineShapesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StablehloRefineShapesPassBase;

  StablehloRefineShapesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloRefineShapesPassBase(const StablehloRefineShapesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StablehloRefineShapesPassBase& operator=(const StablehloRefineShapesPassBase &) = delete;
  StablehloRefineShapesPassBase(StablehloRefineShapesPassBase &&) = delete;
  StablehloRefineShapesPassBase& operator=(StablehloRefineShapesPassBase &&) = delete;
  ~StablehloRefineShapesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-refine-shapes");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-refine-shapes"; }

  ::llvm::StringRef getDescription() const override { return "Refines shapes across a StableHLO program."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloRefineShapesPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloRefineShapesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloRefineShapesPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloRefineShapesPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloRefineShapesPass() {
  return impl::createStablehloRefineShapesPass();
}
#undef GEN_PASS_DEF_STABLEHLOREFINESHAPESPASS
#endif // GEN_PASS_DEF_STABLEHLOREFINESHAPESPASS

//===----------------------------------------------------------------------===//
// VhloLegalizeToStablehloPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_VHLOLEGALIZETOSTABLEHLOPASS
std::unique_ptr<::mlir::Pass> createVhloLegalizeToStablehloPass();
#undef GEN_PASS_DECL_VHLOLEGALIZETOSTABLEHLOPASS
#endif // GEN_PASS_DECL_VHLOLEGALIZETOSTABLEHLOPASS
#ifdef GEN_PASS_DEF_VHLOLEGALIZETOSTABLEHLOPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createVhloLegalizeToStablehloPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class VhloLegalizeToStablehloPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = VhloLegalizeToStablehloPassBase;

  VhloLegalizeToStablehloPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  VhloLegalizeToStablehloPassBase(const VhloLegalizeToStablehloPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  VhloLegalizeToStablehloPassBase& operator=(const VhloLegalizeToStablehloPassBase &) = delete;
  VhloLegalizeToStablehloPassBase(VhloLegalizeToStablehloPassBase &&) = delete;
  VhloLegalizeToStablehloPassBase& operator=(VhloLegalizeToStablehloPassBase &&) = delete;
  ~VhloLegalizeToStablehloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vhlo-legalize-to-stablehlo");
  }
  ::llvm::StringRef getArgument() const override { return "vhlo-legalize-to-stablehlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize VHLO to StableHLO."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VhloLegalizeToStablehloPass");
  }
  ::llvm::StringRef getName() const override { return "VhloLegalizeToStablehloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::quant::QuantizationDialect>();
    registry.insert<mlir::shape::ShapeDialect>();
    registry.insert<mlir::stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VhloLegalizeToStablehloPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createVhloLegalizeToStablehloPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createVhloLegalizeToStablehloPass() {
  return impl::createVhloLegalizeToStablehloPass();
}
#undef GEN_PASS_DEF_VHLOLEGALIZETOSTABLEHLOPASS
#endif // GEN_PASS_DEF_VHLOLEGALIZETOSTABLEHLOPASS

//===----------------------------------------------------------------------===//
// VhloToVersionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_VHLOTOVERSIONPASS
struct VhloToVersionPassOptions {
  std::string targetVersionOption;
};
std::unique_ptr<::mlir::Pass> createVhloToVersionPass();
std::unique_ptr<::mlir::Pass> createVhloToVersionPass(const VhloToVersionPassOptions &options);
#undef GEN_PASS_DECL_VHLOTOVERSIONPASS
#endif // GEN_PASS_DECL_VHLOTOVERSIONPASS
#ifdef GEN_PASS_DEF_VHLOTOVERSIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createVhloToVersionPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createVhloToVersionPass(const VhloToVersionPassOptions &options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class VhloToVersionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = VhloToVersionPassBase;

  VhloToVersionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  VhloToVersionPassBase(const VhloToVersionPassBase &other) : ::mlir::OperationPass<>(other) {}
  VhloToVersionPassBase& operator=(const VhloToVersionPassBase &) = delete;
  VhloToVersionPassBase(VhloToVersionPassBase &&) = delete;
  VhloToVersionPassBase& operator=(VhloToVersionPassBase &&) = delete;
  ~VhloToVersionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vhlo-to-version");
  }
  ::llvm::StringRef getArgument() const override { return "vhlo-to-version"; }

  ::llvm::StringRef getDescription() const override { return "Convert between versions of VHLO."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VhloToVersionPass");
  }
  ::llvm::StringRef getName() const override { return "VhloToVersionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VhloToVersionPassBase<DerivedT>)

  VhloToVersionPassBase(const VhloToVersionPassOptions &options) : VhloToVersionPassBase() {
    targetVersionOption = options.targetVersionOption;
  }
protected:
  ::mlir::Pass::Option<std::string> targetVersionOption{*this, "target", ::llvm::cl::desc("The target version. Must be a version of the form #.#.# or 'current'.")};
private:

  friend std::unique_ptr<::mlir::Pass> createVhloToVersionPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createVhloToVersionPass(const VhloToVersionPassOptions &options) {
    return std::make_unique<DerivedT>(options);
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createVhloToVersionPass() {
  return impl::createVhloToVersionPass();
}

std::unique_ptr<::mlir::Pass> createVhloToVersionPass(const VhloToVersionPassOptions &options) {
  return impl::createVhloToVersionPass(options);
}
#undef GEN_PASS_DEF_VHLOTOVERSIONPASS
#endif // GEN_PASS_DEF_VHLOTOVERSIONPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ChloLegalizeToStablehloPass Registration
//===----------------------------------------------------------------------===//

inline void registerChloLegalizeToStablehloPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createChloLegalizeToStablehloPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerChloLegalizeToStablehloPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createChloLegalizeToStablehloPass();
  });
}

//===----------------------------------------------------------------------===//
// ShapeLegalizeToStablehloPass Registration
//===----------------------------------------------------------------------===//

inline void registerShapeLegalizeToStablehloPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createShapeLegalizeToStablehloPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerShapeLegalizeToStablehloPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createShapeLegalizeToStablehloPass();
  });
}

//===----------------------------------------------------------------------===//
// StablehloAggressiveFolderPass Registration
//===----------------------------------------------------------------------===//

inline void registerStablehloAggressiveFolderPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloAggressiveFolderPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloAggressiveFolderPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloAggressiveFolderPass();
  });
}

//===----------------------------------------------------------------------===//
// StablehloAggressiveSimplificationPass Registration
//===----------------------------------------------------------------------===//

inline void registerStablehloAggressiveSimplificationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloAggressiveSimplificationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloAggressiveSimplificationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloAggressiveSimplificationPass();
  });
}

//===----------------------------------------------------------------------===//
// StablehloCanonicalizeDynamismPass Registration
//===----------------------------------------------------------------------===//

inline void registerStablehloCanonicalizeDynamismPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloCanonicalizeDynamismPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloCanonicalizeDynamismPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloCanonicalizeDynamismPass();
  });
}

//===----------------------------------------------------------------------===//
// StablehloConvertToSignlessPass Registration
//===----------------------------------------------------------------------===//

inline void registerStablehloConvertToSignlessPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloConvertToSignlessPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloConvertToSignlessPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloConvertToSignlessPass();
  });
}

//===----------------------------------------------------------------------===//
// StablehloInstrumentWithProbePass Registration
//===----------------------------------------------------------------------===//

inline void registerStablehloInstrumentWithProbePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloInstrumentWithProbePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloInstrumentWithProbePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloInstrumentWithProbePass();
  });
}

//===----------------------------------------------------------------------===//
// StablehloLegalizeCompositeToCallPass Registration
//===----------------------------------------------------------------------===//

inline void registerStablehloLegalizeCompositeToCallPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloLegalizeCompositeToCallPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloLegalizeCompositeToCallPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloLegalizeCompositeToCallPass();
  });
}

//===----------------------------------------------------------------------===//
// StablehloLegalizeDeprecatedOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerStablehloLegalizeDeprecatedOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloLegalizeDeprecatedOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloLegalizeDeprecatedOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloLegalizeDeprecatedOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// StablehloLegalizeToVhloPass Registration
//===----------------------------------------------------------------------===//

inline void registerStablehloLegalizeToVhloPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloLegalizeToVhloPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloLegalizeToVhloPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloLegalizeToVhloPass();
  });
}

//===----------------------------------------------------------------------===//
// StablehloRefineArgumentsPass Registration
//===----------------------------------------------------------------------===//

inline void registerStablehloRefineArgumentsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloRefineArgumentsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloRefineArgumentsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloRefineArgumentsPass();
  });
}

//===----------------------------------------------------------------------===//
// StablehloRefineShapesPass Registration
//===----------------------------------------------------------------------===//

inline void registerStablehloRefineShapesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloRefineShapesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloRefineShapesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloRefineShapesPass();
  });
}

//===----------------------------------------------------------------------===//
// VhloLegalizeToStablehloPass Registration
//===----------------------------------------------------------------------===//

inline void registerVhloLegalizeToStablehloPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createVhloLegalizeToStablehloPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerVhloLegalizeToStablehloPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createVhloLegalizeToStablehloPass();
  });
}

//===----------------------------------------------------------------------===//
// VhloToVersionPass Registration
//===----------------------------------------------------------------------===//

inline void registerVhloToVersionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createVhloToVersionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerVhloToVersionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createVhloToVersionPass();
  });
}

//===----------------------------------------------------------------------===//
//  Registration
//===----------------------------------------------------------------------===//

inline void registerPasses() {
  registerChloLegalizeToStablehloPass();
  registerShapeLegalizeToStablehloPass();
  registerStablehloAggressiveFolderPass();
  registerStablehloAggressiveSimplificationPass();
  registerStablehloCanonicalizeDynamismPass();
  registerStablehloConvertToSignlessPass();
  registerStablehloInstrumentWithProbePass();
  registerStablehloLegalizeCompositeToCallPass();
  registerStablehloLegalizeDeprecatedOpsPass();
  registerStablehloLegalizeToVhloPass();
  registerStablehloRefineArgumentsPass();
  registerStablehloRefineShapesPass();
  registerVhloLegalizeToStablehloPass();
  registerVhloToVersionPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class ChloLegalizeToStablehloPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = ChloLegalizeToStablehloPassBase;

  ChloLegalizeToStablehloPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ChloLegalizeToStablehloPassBase(const ChloLegalizeToStablehloPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  ChloLegalizeToStablehloPassBase& operator=(const ChloLegalizeToStablehloPassBase &) = delete;
  ChloLegalizeToStablehloPassBase(ChloLegalizeToStablehloPassBase &&) = delete;
  ChloLegalizeToStablehloPassBase& operator=(ChloLegalizeToStablehloPassBase &&) = delete;
  ~ChloLegalizeToStablehloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("chlo-legalize-to-stablehlo");
  }
  ::llvm::StringRef getArgument() const override { return "chlo-legalize-to-stablehlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes from CHLO ops flow to StableHLO and Shape ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ChloLegalizeToStablehloPass");
  }
  ::llvm::StringRef getName() const override { return "ChloLegalizeToStablehloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::shape::ShapeDialect>();
    registry.insert<mlir::stablehlo::StablehloDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ChloLegalizeToStablehloPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ShapeLegalizeToStablehloPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = ShapeLegalizeToStablehloPassBase;

  ShapeLegalizeToStablehloPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeLegalizeToStablehloPassBase(const ShapeLegalizeToStablehloPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  ShapeLegalizeToStablehloPassBase& operator=(const ShapeLegalizeToStablehloPassBase &) = delete;
  ShapeLegalizeToStablehloPassBase(ShapeLegalizeToStablehloPassBase &&) = delete;
  ShapeLegalizeToStablehloPassBase& operator=(ShapeLegalizeToStablehloPassBase &&) = delete;
  ~ShapeLegalizeToStablehloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-legalize-to-stablehlo");
  }
  ::llvm::StringRef getArgument() const override { return "shape-legalize-to-stablehlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize shape-related ops to StableHLO."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeLegalizeToStablehloPass");
  }
  ::llvm::StringRef getName() const override { return "ShapeLegalizeToStablehloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeLegalizeToStablehloPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StablehloAggressiveFolderPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloAggressiveFolderPassBase;

  StablehloAggressiveFolderPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloAggressiveFolderPassBase(const StablehloAggressiveFolderPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloAggressiveFolderPassBase& operator=(const StablehloAggressiveFolderPassBase &) = delete;
  StablehloAggressiveFolderPassBase(StablehloAggressiveFolderPassBase &&) = delete;
  StablehloAggressiveFolderPassBase& operator=(StablehloAggressiveFolderPassBase &&) = delete;
  ~StablehloAggressiveFolderPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-aggressive-folder");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-aggressive-folder"; }

  ::llvm::StringRef getDescription() const override { return "Folds StableHLO operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloAggressiveFolderPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloAggressiveFolderPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloAggressiveFolderPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StablehloAggressiveSimplificationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloAggressiveSimplificationPassBase;

  StablehloAggressiveSimplificationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloAggressiveSimplificationPassBase(const StablehloAggressiveSimplificationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloAggressiveSimplificationPassBase& operator=(const StablehloAggressiveSimplificationPassBase &) = delete;
  StablehloAggressiveSimplificationPassBase(StablehloAggressiveSimplificationPassBase &&) = delete;
  StablehloAggressiveSimplificationPassBase& operator=(StablehloAggressiveSimplificationPassBase &&) = delete;
  ~StablehloAggressiveSimplificationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-aggressive-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-aggressive-simplification"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalizes StableHLO operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloAggressiveSimplificationPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloAggressiveSimplificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloAggressiveSimplificationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StablehloCanonicalizeDynamismPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloCanonicalizeDynamismPassBase;

  StablehloCanonicalizeDynamismPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloCanonicalizeDynamismPassBase(const StablehloCanonicalizeDynamismPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloCanonicalizeDynamismPassBase& operator=(const StablehloCanonicalizeDynamismPassBase &) = delete;
  StablehloCanonicalizeDynamismPassBase(StablehloCanonicalizeDynamismPassBase &&) = delete;
  StablehloCanonicalizeDynamismPassBase& operator=(StablehloCanonicalizeDynamismPassBase &&) = delete;
  ~StablehloCanonicalizeDynamismPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-canonicalize-dynamism");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-canonicalize-dynamism"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalizes dynamic StableHLO ops into static ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloCanonicalizeDynamismPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloCanonicalizeDynamismPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloCanonicalizeDynamismPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StablehloConvertToSignlessPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StablehloConvertToSignlessPassBase;

  StablehloConvertToSignlessPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloConvertToSignlessPassBase(const StablehloConvertToSignlessPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StablehloConvertToSignlessPassBase& operator=(const StablehloConvertToSignlessPassBase &) = delete;
  StablehloConvertToSignlessPassBase(StablehloConvertToSignlessPassBase &&) = delete;
  StablehloConvertToSignlessPassBase& operator=(StablehloConvertToSignlessPassBase &&) = delete;
  ~StablehloConvertToSignlessPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-convert-to-signless");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-convert-to-signless"; }

  ::llvm::StringRef getDescription() const override { return "Pass to transform the IR to be on signless integers."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloConvertToSignlessPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloConvertToSignlessPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloConvertToSignlessPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StablehloInstrumentWithProbePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StablehloInstrumentWithProbePassBase;

  StablehloInstrumentWithProbePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloInstrumentWithProbePassBase(const StablehloInstrumentWithProbePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StablehloInstrumentWithProbePassBase& operator=(const StablehloInstrumentWithProbePassBase &) = delete;
  StablehloInstrumentWithProbePassBase(StablehloInstrumentWithProbePassBase &&) = delete;
  StablehloInstrumentWithProbePassBase& operator=(StablehloInstrumentWithProbePassBase &&) = delete;
  ~StablehloInstrumentWithProbePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-instrument-with-probe");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-instrument-with-probe"; }

  ::llvm::StringRef getDescription() const override { return "Inserts probe instrumentation instructions in a StableHLO program."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloInstrumentWithProbePass");
  }
  ::llvm::StringRef getName() const override { return "StablehloInstrumentWithProbePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::stablehlo::interpreter::InterpreterDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloInstrumentWithProbePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> useDebugInfoOption{*this, "useDebugInfo", ::llvm::cl::desc("Whether or not to use location debug data as `probe_id` values."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class StablehloLegalizeCompositeToCallPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloLegalizeCompositeToCallPassBase;

  StablehloLegalizeCompositeToCallPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloLegalizeCompositeToCallPassBase(const StablehloLegalizeCompositeToCallPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloLegalizeCompositeToCallPassBase& operator=(const StablehloLegalizeCompositeToCallPassBase &) = delete;
  StablehloLegalizeCompositeToCallPassBase(StablehloLegalizeCompositeToCallPassBase &&) = delete;
  StablehloLegalizeCompositeToCallPassBase& operator=(StablehloLegalizeCompositeToCallPassBase &&) = delete;
  ~StablehloLegalizeCompositeToCallPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-legalize-composite-to-call");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-legalize-composite-to-call"; }

  ::llvm::StringRef getDescription() const override { return "Replaces composite ops with a call to their decomposition"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloLegalizeCompositeToCallPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloLegalizeCompositeToCallPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloLegalizeCompositeToCallPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<std::string> exceptListOption{*this, "except", ::llvm::cl::desc("Names of composites that should not be replaced with calls.")};
};

template <typename DerivedT>
class StablehloLegalizeDeprecatedOpsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloLegalizeDeprecatedOpsPassBase;

  StablehloLegalizeDeprecatedOpsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloLegalizeDeprecatedOpsPassBase(const StablehloLegalizeDeprecatedOpsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloLegalizeDeprecatedOpsPassBase& operator=(const StablehloLegalizeDeprecatedOpsPassBase &) = delete;
  StablehloLegalizeDeprecatedOpsPassBase(StablehloLegalizeDeprecatedOpsPassBase &&) = delete;
  StablehloLegalizeDeprecatedOpsPassBase& operator=(StablehloLegalizeDeprecatedOpsPassBase &&) = delete;
  ~StablehloLegalizeDeprecatedOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-legalize-deprecated-ops");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-legalize-deprecated-ops"; }

  ::llvm::StringRef getDescription() const override { return "Legalize deprecated ops to well-supported ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloLegalizeDeprecatedOpsPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloLegalizeDeprecatedOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloLegalizeDeprecatedOpsPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> failOnUnusedOps{*this, "fail-on-unused", ::llvm::cl::desc("Fail on (mostly) unused ops that are deprecated without any fallback."), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class StablehloLegalizeToVhloPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StablehloLegalizeToVhloPassBase;

  StablehloLegalizeToVhloPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloLegalizeToVhloPassBase(const StablehloLegalizeToVhloPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StablehloLegalizeToVhloPassBase& operator=(const StablehloLegalizeToVhloPassBase &) = delete;
  StablehloLegalizeToVhloPassBase(StablehloLegalizeToVhloPassBase &&) = delete;
  StablehloLegalizeToVhloPassBase& operator=(StablehloLegalizeToVhloPassBase &&) = delete;
  ~StablehloLegalizeToVhloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-legalize-to-vhlo");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-legalize-to-vhlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize StableHLO to VHLO."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloLegalizeToVhloPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloLegalizeToVhloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vhlo::VhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloLegalizeToVhloPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StablehloRefineArgumentsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StablehloRefineArgumentsPassBase;

  StablehloRefineArgumentsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloRefineArgumentsPassBase(const StablehloRefineArgumentsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StablehloRefineArgumentsPassBase& operator=(const StablehloRefineArgumentsPassBase &) = delete;
  StablehloRefineArgumentsPassBase(StablehloRefineArgumentsPassBase &&) = delete;
  StablehloRefineArgumentsPassBase& operator=(StablehloRefineArgumentsPassBase &&) = delete;
  ~StablehloRefineArgumentsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-refine-arguments");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-refine-arguments"; }

  ::llvm::StringRef getDescription() const override { return "Refines the argument shapes of the main function."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloRefineArgumentsPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloRefineArgumentsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloRefineArgumentsPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<std::string> refinedTypesOption{*this, "types", ::llvm::cl::desc("The new types to be used for the main function's arguments, specified as an MLIR TypeRange 'tensor<1x2xf32>, ...'")};
};

template <typename DerivedT>
class StablehloRefineShapesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StablehloRefineShapesPassBase;

  StablehloRefineShapesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloRefineShapesPassBase(const StablehloRefineShapesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  StablehloRefineShapesPassBase& operator=(const StablehloRefineShapesPassBase &) = delete;
  StablehloRefineShapesPassBase(StablehloRefineShapesPassBase &&) = delete;
  StablehloRefineShapesPassBase& operator=(StablehloRefineShapesPassBase &&) = delete;
  ~StablehloRefineShapesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-refine-shapes");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-refine-shapes"; }

  ::llvm::StringRef getDescription() const override { return "Refines shapes across a StableHLO program."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloRefineShapesPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloRefineShapesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloRefineShapesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class VhloLegalizeToStablehloPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = VhloLegalizeToStablehloPassBase;

  VhloLegalizeToStablehloPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  VhloLegalizeToStablehloPassBase(const VhloLegalizeToStablehloPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  VhloLegalizeToStablehloPassBase& operator=(const VhloLegalizeToStablehloPassBase &) = delete;
  VhloLegalizeToStablehloPassBase(VhloLegalizeToStablehloPassBase &&) = delete;
  VhloLegalizeToStablehloPassBase& operator=(VhloLegalizeToStablehloPassBase &&) = delete;
  ~VhloLegalizeToStablehloPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vhlo-legalize-to-stablehlo");
  }
  ::llvm::StringRef getArgument() const override { return "vhlo-legalize-to-stablehlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize VHLO to StableHLO."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VhloLegalizeToStablehloPass");
  }
  ::llvm::StringRef getName() const override { return "VhloLegalizeToStablehloPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::quant::QuantizationDialect>();
    registry.insert<mlir::shape::ShapeDialect>();
    registry.insert<mlir::stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VhloLegalizeToStablehloPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class VhloToVersionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = VhloToVersionPassBase;

  VhloToVersionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  VhloToVersionPassBase(const VhloToVersionPassBase &other) : ::mlir::OperationPass<>(other) {}
  VhloToVersionPassBase& operator=(const VhloToVersionPassBase &) = delete;
  VhloToVersionPassBase(VhloToVersionPassBase &&) = delete;
  VhloToVersionPassBase& operator=(VhloToVersionPassBase &&) = delete;
  ~VhloToVersionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vhlo-to-version");
  }
  ::llvm::StringRef getArgument() const override { return "vhlo-to-version"; }

  ::llvm::StringRef getDescription() const override { return "Convert between versions of VHLO."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VhloToVersionPass");
  }
  ::llvm::StringRef getName() const override { return "VhloToVersionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VhloToVersionPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> targetVersionOption{*this, "target", ::llvm::cl::desc("The target version. Must be a version of the form #.#.# or 'current'.")};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
